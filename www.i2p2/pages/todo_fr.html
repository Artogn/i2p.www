{% extends "_layout_fr.html" %}
{% block title %}&Agrave; faire / Sur le feu{% endblock %}
{% block content %} 
  <h1>Cibles du project I2P</h1>
Traduction en cours (25 f&eacute;v 2011)
  <p>Vous trouverez ci-dessous une exposition plus d&eacute;taill&eacute;e (bien que toujours incompl&egrave;te) 
    des principales zones du d&eacute;veloppement du c&oelig;ur du r&eacute;seau I2P, embrassant les
    nouvelles versions &eacute;ventuellement planifi&eacute;es. Ceci n'inclu ni le transport st&eacute;ganographique, 
    ni les outils de s&eacute;curisation de la machine locale et l'adaptation  aux p&eacute;riph&eacute;riques radio (WiFi), pas plus que les applications clientes 
    qui sont tous essentiels pour le succ&egrave;s du r&eacute;seau I2P. Il y a probablement d'autres choses qui 
    viendront, particuli&egrave;rement quand I2P sera mieux test&eacute;, mais il s'agit l&agrave; des principaux 
    "gros morceaux". Voir aussi la <a href="roadmap_fr.html">feuille de route</a>. Vous voulez nous aider? <a href="getinvolved.html">Engagez-vous!</a></p>
  <br />
  <h2>Fonctionalit&eacute;s centrales <font size="-1"><a href="#core">[hop]</a></font></h2>
  <ul class="targetlist">
    <li><a href="#nat">Pontage du Pare-feu/NAT via une route r&eacute;serv&eacute;e &agrave; 1 saut.</a></li>
    <li><a href="#transport">Couche transport de haut-niveau par UDP, NBIO, ou NIO.</a></li>
    <li><a href="#netdb">Base de donn&eacute;e r&eacute;seau, ajustement de profil et strat&eacute;gie d'&eacute;jection pour les grands r&eacute;seaux.</a></li>
  </ul>
  <h2>S&eacute;curit&eacute; / anonymat <font size="-1"><a href="#security">[zyva]</a></font></h2>
  <ul class="targetlist">
    <li><a href="#tunnelId">ID de tunnel "par saut" &amp; nouvelle encryption permut&eacute;e de la structure de v&eacute;rification des tunnels.</a></li>
    <li><a href="#ordering">Tri strict des participants des tunnels.</a></li>
    <li><a href="#tunnelLength">Longueur des tunnels al&eacute;atoirement permut&eacute;e.</a></li>
    <li><a href="#fullRestrictedRoutes">Routes r&eacute;serv&eacute;es &agrave; n-sauts finalis&eacute;es avec liens de confiance optionnels.</a></li>
    <li><a href="#hashcash">Hashcash pour routerIdentity, destination, et demande de tunnel.</a></li>
    <li><a href="#batching">Fonctionnement &eacute;tendu des tunnels (batching/mixing/throttling/padding)</a></li>
    <li><a href="#stop">M&eacute;lange de Stop &amp; go pour les <a href="http://www.i2p2.de/how_garlicrouting.html">"garlics"</a> et les tunnels</a></li>
  </ul>
  <h2>Performances <font size="-1"><a href="performance.html">[doigt]</a></font></h2>
  <h2 id="core">Fonctionalit&eacute;s centrales</h2>
  <ul class="targetlist">
    <li> 
      <h3 id="nat">Pontage du Pare-feu/NAT via une route r&eacute;serv&eacute;e &agrave; 1 saut.</h3>
    </li>
    <b><i>Impl&eacute;ment&eacute; dans I2P 0.6.0.6</i></b> 
    <p>La fonctionalit&eacute; permettant aux routeurs de participer pleinement aux r&eacute;seau  
      m&ecirc;me lorsqu'ils se trouvent derri&egrave;re un pare-feu ou un traducteur d'adresses r&eacute;seau (NAT) hors de contr&ocirc;le n&eacute;cessite quelques 
      op&eacute;rations avec une route r&eacute;serv&eacute;e (car ces pairs ne peuvent pas recevoir 
      de connexions entrantes). Pour y parvenir, il y a deux fa&ccedil;ons de consid&eacute;rer les pairs:</p>
  </ul>
  <ul>
    <li><b>Pairs disposant d'interfaces joignables</b> - ils n'ont rien de particulier &agrave; faire.</li>
    <li><b>Pairs ne disposant pas d'interfaces joignables</b> - ces pairs doivent cr&eacute;er 
      un tunnel pointant sur eux dans lequel la passerelle est un des pairs avec lesquels ils ont &eacute;tabli une connexion
      et qui, lui, dispose d'une interface publiquement joignable et a accept&eacute; de jouer le r&ocirc;le "d'entremetteur".</li>
  </ul>
  <ul class="targetlist">
    <p>Pour ce faire, les pairs priv&eacute;s se connectent simplement &agrave; quelques autres, 
      cr&eacute;ent un tunnel &agrave; travers chacun d'eux, et en publient une r&eacute;f&eacute;rence dans leur  
      structure RouterInfo de la base de donn&eacute;e du r&eacute;seau.</p>
    <p>Lorsque quelqu'un souhaite joindre un routeur particulier, il doit d'abord obtenir 
      sa "RouterInfo" &agrave; partir de la base de donn&eacute;e, et il saura s'il peut se connecter  
      directement (cas du pair cible public) ou indirectement. Les connexions directes se passent
      normalement, alors que les indirectes se font via les tunnels publi&eacute;s.</p>
    <p>Quand un routeur veut seulement envoyer un ou deux messages &agrave; un pair cach&eacute;, 
      il peut simplement utiliser le tunnel indirect publi&eacute; pour envoyer les donn&eacute;es utiles. Cependant, 
      si le routeur doit converser souvent avec le pair priv&eacute; (par exemple en tant que participant 
      &agrave; un tunnel), il doit envoyer un message "rout&eacute;-&agrave;-la-garlic" &agrave; travers le tunnel
      indirect au pair cach&eacute;, qui le d&eacute;balle pour y trouver... un message destin&eacute; au routeur originaire.
      Le pair cach&eacute; &eacute;tablit alors une connexion sortante 
      au routeur originaire et &agrave; partir de l&agrave; ces deux  
      routeurs peuvent converser directement sur cette nouvelle connexion.</p>
    <p>Ce sc&eacute;nario ne peut bien s&ucirc;r fonctionner que si le pair originaire peut recevoir des connexions 
      (c'est-&agrave;-dire qu'il ne soit pas lui-m&ecirc;me cach&eacute;). Cependant, s'il est cach&eacute; lui aussi, il peut indiquer dans 
      le message initial de revenir par son propre tunnel d'entr&eacute;e.</p>
    <p>Ceci n'est pas destin&eacute; &agrave; fournir aux pairs un moyen de dissimuler leur adresse IP, 
      mais plut&ocirc;t pour permettre &agrave; ceux op&eacute;rant derri&egrave;re un pare-feu ou un NAT de participer normalement 
      au r&eacute;seau. La dissimulation d'adresse IP demande plus de travail, comme  
      d&eacute;crit <a href="#fullRestrictedRoutes">plus bas</a>.</p>
    <p>Avec cette m&eacute;thode, n'importe quel routeur peut participer &agrave; tout r&ocirc;le dans un tunnel. 
      Dans un but d'efficacit&eacute;, op&eacute;rer en pair cach&eacute; est un mauvais choix pour officier en tant que passerelle d'entr&eacute;e, 
      et dans un tunnel donn&eacute;, deux pairs voisins ne devraient pas &ecirc;tre cach&eacute;s. Mais &ccedil;a n'est pas indispensable.</p>
  </ul>
  <ul class="targetlist">
    <li> 
      <h3 id="transport">Couche transport de haut-niveau par UDP, NBIO, ou NIO.</h3>
      <b><i>UDP et NIO sont impl&eacute;ment&eacute;s dans I2P</i></b> 
      <p>La communication TCP standard dans Java n&eacute;cessite habituellement des appels de socket 
        bloquants, et pour pour emp&ecirc;cher un socket de bloquer le bloquer tout le syst&egrave;me, ces  
        appels sont faits dans leur propres t&acirc;ches. Notre transport TCP actuel
        est impl&eacute;ment&eacute; de fa&ccedil;on na&iuml;ve - pour chaque pair en relation, nous avons 
        une t&acirc;che de lecture et une t&acirc;che d'&eacute;criture. Celle de lecture boucle simplement sur  
        un paquet d'appels read(), construit les messages I2NP et les ajoute &agrave; notre file d'attente 
        interne entrante. Il y a une file d'attente de messages sortants par connexion. La t&acirc;che d'&eacute;criture en extrait les messages 
        et passe les donn&eacute;es &agrave; travers les appels write().</p>
      <p>Nous effectuons ceci assez efficacement d'un point de vue charge UC - &agrave; tout moment, 
        presque toutes ces t&acirc;ches sont au repos, bloqu&eacute;es dans l'attente de grain &agrave; moudre. 
        Cependant, chacune d'entre elles consomme des ressources r&eacute;elles (par exemple sur de tr&egrave;s vieux  
        noyaux Linux, chacune sera souvent mise en &oelig;uvre en tant que processus fork()'ed). 
        &Agrave; mesure de la croissance du r&eacute;seau, le nombre de pairs auxquels chaque routeur voudra s'adresser 
        augmentera (souvenez-vous, I2P est enti&egrave;rement connect&eacute;, c'est-&agrave;-dire que chaque pair doit savoir 
        comment passer des messages &agrave; tous les autres. Le support des routes r&eacute;serv&eacute;es  
        ne r&eacute;duira probablement pas sensiblement le nombre de connexions 
        n&eacute;cessaires). Ce qui veut dire que dans un r&eacute;seau de 100000 routeurs, chaque routeur 
        aura jusqu'&agrave; 199998 t&acirc;ches rien que pour s'occuper des connexions TCP!</p>
      <p>&Eacute;videment, &ccedil;a ne marchera pas. Nous avons besoin d'une couche transport adaptative. 
        Dans Java, nous disposons de deux approches principales:</p>
      <h4>UDP</h4>
      <b><i>Impl&eacute;ment&eacute; dans I2P 0.6 ("SSU") tel que document&eacute; <a href="udp.html">ailleurs</a>.</i></b> 
      <p>L'envoi et la r&eacute;ception de datagrammes UDP sont des op&eacute;rations sans connexion - si 
        on communique avec 100000 pairs, on colle simplement les paquets UDP dans une file 
        d'attente et on fait avec une seule t&acirc;che pour les extraire et les pousser dans le tuyau 
        (et pour recevoir, une seule t&acirc;che en tire les paquets UDP re&ccedil;us et les ajoute dans une file d'entr&eacute;e).</p>
      <p>L'ennui, c'est que l'utilisation de UDP fait perdre les avantages de TCP (r&eacute;ordonnancement, gestion de la congestion, 
        d&eacute;couverte du MTU, etc). Mettre ce code en &oelig;uvre demandera un travail important, 
        mais I2P n'a pas besoin d'&ecirc;tre aussi solide que TCP. Pr&eacute;cis&eacute;ment, 
        lorsque j'ai fait des mesures au simulateur et en r&eacute;el sur Internet,  
        la plupart des messages transf&eacute;r&eacute;s tenaient facilement dans un seul paquet UDP 
        non fragment&eacute;, et les plus gros messages prenaient 20 &agrave; 30 paquets.
        Comme <i>mule</i> le mit en &eacute;vidence, TCP ajoute une surcharge certaine quand il s'agit de g&eacute;rer 
        autant de petits paquets, vu que les ACKs sont du m&ecirc;me ordre de grandeur.
        Avec UDP, nous pouvons optimiser le transport tant pour l'efficacit&eacute; que pour la souplesse
        en prenant en compte les besoins sp&eacute;cifiques d'I2P.</p>
      <p>&Ccedil;a ne va quand-m&ecirc;me pas &ecirc;tre un travail &eacute;norme.</p>
      <h4>NIO or NBIO</h4>
      <b><i>NIO implémenté dans I2P 0.6.1.22 ("NTCP")</i></b> 
      <p>Java 1.4 propose un jeu de paquetage "New I/O", permettant aux  
        développeurs de tirer avantage des possibilités d'E/S non blocantes du système d'exploitation 
        - vous pouvez maintenir un grand nombre d'opérations d'E/S simultanées sans avoir besoin de définir une tâche 
        dédiée pour chacune. Cette approche est très prometteuse, car nous pouvons utiliser un grand nombre de connexion 
        simultanées et nous n'avons pas besoin d'écrire une mini-pile TCP pour UDP. Cependant, selon les développeurs
        de Freenet les paquetages NIO n'ont passé l'épreuve du feu. De plus, le recours aux NIO impliquerait une 
        incompatibilité avec les JVM open-sources telles que <a href="http://www.kaffe.org/">Kaffe</a>, car 
        <a href="http://www.classpath.org/">GNU/Classpath</a> ne les supporte que partiellement. <i>(note: ça ne devrait 
        pas durer car il y a eu quelques progrès dans les NIO de Classpath, bien qu'en quantité inconnue)</i></p>
      <p>Dans la même veine, il y a l'alternative du paquetage 
        <a href="http://www.eecs.harvard.edu/~mdw/proj/java-nbio/">Non blocking IO</a> - 
        essentiellement une implémentation NIO de salle blanche (écrite avant la parution des NIO). 
        Il utilise du code natif du SE pour faire les E/S non blocantes, en présentant les évènements via Java. 
        Il semble fonctionner avec Kaffe, mais il a peu d'activité de développement à son sujet (probablement 
        à cause de la parution des NIO de Java 1.4).</p>
    </li>
  </ul>
  <ul class="targetlist">
    <li> 
      <h3 id="netdb">Base de donn&eacute;e r&eacute;seau, ajustement de profil et strat&eacute;gie d'&eacute;jection pour les grands r&eacute;seaux.</h3>
      <p>Dans l'implémentation actuelle de la base de donnée réseau et de la gestion de profil, 
        on s'est permi quelques raccourcis pratiques. Par exemple, nous n'avons pas de code pour 
        nettoyer les références aux pairs dans les K-buckets, vu que nous n'avons pas assez de pairs pour avoir ne 
        serait-ce qu'une petite chance d'en remplir une. Alors on garde les pairs dans n'importe quelle liste appropriée. 
        Un autre exemple avec les profils de pairs: la quantité de mémoire nécessaire pour maintenir chaque profil est suffisament 
        faible pour que nous puissions garder des milliers de profils bien détaillés sans aucun problème. 
        Comme nous avons la possibilité d'utiliser des profils réduits (dont nous pouvons maintenir des centaines de 
        milliers en mémoire), nous n'avons pas non-plus le code qui ferait la conversion de détaillé en réduit et vice-versa,
        ni même la purge des deux. Ça ne serait pertinent d'écrire ce code maintenant car nous sommes loin d'en avoir besoin 
        avant longtemps.</p>
      <p>Ceci dit, nous devons quand même garder ça en tête car la taille du réseau grandit. 
         Il restera du travail, mais on peut le remettre à plus tard.</p>
    </li>
  </ul>
  <h2 id="security">Sécurité / anonymat</h2>
  <ul class="targetlist">
    <li> 
      <h3 id="tunnelId">ID de tunnel "par saut" &amp; nouvelle encryption permut&eacute;e de la structure de v&eacute;rification des tunnels. TunnelVerificationStructure 
        encryption</h3>
      <b><i>Depuis I2P v0.5 et documenté <a href="tunnel-alt.html">là</a>.</i></b> 
      <p>À l'heure actuelle, quand Alice initie un tunnel entrant à quatre sauts commençant par Elvis, 
        puis passant par Dave, puis Charlie,puis Bob, et se terminant chez elle, Alice (A&lt;--B&lt;--C&lt;--D&lt;--E), 
        tous les cinq sont au fait qu'ils participent au tunnel "123", car 
        les messages font en font état (TunnelID commun). Nous voulons donner à chaque saut un 
        identifiant unique de saut de tunnel:Charlie recevra des messages sur le tunnel 234 
        et les transmettra à Bob par le tunnel 876. Le but est d'empêcher Bob ou 
        Charlie de savoir qu'ils participent au tunnel d'Alice, car quand chaque saut 
        a le même tunnelID pour un tunnel donné, les attaques par coalition sont simples à mettre en &oelig;uvre. 
      </p> 
      <p>L'ajout d'un TunnelID unique par saut n'est pas difficile, mais c'est insuffisant: 
        Si Dave et Bob sont contrôlés par le même attaquant, ils ne pourraient plus identifier un tunnel 
        par leur participation commune via l'information TunnelID, mais seraient quand-même capable de le  
        faire par simple comparaison des corps de messages et des structures de vérification.
        Pour l'empêcher, le tunnel doit appliquer un cryptage étagé tout au long du chemin, 
        à la fois sur la charge utile et les structures de vérification (utilisées pour empêcher les attaques 
        par marquages). On a besoin de modifications simples du TunnelMessage, et aussi d'inclure par saut, des clés
        secrètes générées pendant la création du tunnel et passées à la passerelle du tunnel.
        Nous devons définir une longueur maximale de tunnel (p.e. 16 sauts) 
        et indiquer à la passerelle de chiffrer le message pour chacune des 16 clés, 
        en ordre inverse, et de crypter la signature du hachage de la charge utile (cryptée) à chaque étape. 
        La passerelle envoie alors ce message au premier saut chiffré 16 fois, accompagné d'un plan 
        à 16 entrée chiffré 16 fois. Le premier saut déchiffre le plan et la charge utile avec leur clef secrète 
        pour chercher dans le plan l'entrée associée à son propre saut (indiquée par le tunnelID unique par saut) 
        et pour vérifier la charge utile en la confrontant au hachage signé associé.
      </p>
      <p>La passerelle dispose encore de plus d'informations que les autre pairs, 
        et sa compromission avec un participant leur permettrait d'indentier leur participation à un tunnel donné.
        De toute façon, les pairs voisins savent qu'ils participent au même tunnel, car ils savent à qui ils 
        envoient un message (et avec les transport IP sans routes réservées, ils savent aussi de qui ils reçoivent). 
        Malgré tout, les deux techniques ci-dessus augmentent très sensiblement le coût d'obtension d'échantillons 
        signifiants dans des tunnels très longs.</p>
    </li>
    <ul class="targetlist">
      <li> 
        <h3 id="ordering">Strict ordering of participants within tunnels</h3>
        <b><i>Implemented in release 0.6.2</i></b></li>
    </ul>
    <ul class="targetlist">
      <p>As Connelly <a href="http://dev.i2p/pipermail/i2p/2004-July/000335.html">proposed</a> 
        to deal with the <a href="http://prisms.cs.umass.edu/brian/pubs/wright-tissec.pdf">predecessor 
        attack</a> <a href="http://prisms.cs.umass.edu/brian/pubs/wright.tissec.2008.pdf">(2008 
        update)</a>, keeping the order of peers within our tunnels consistent 
        (aka whenever Alice creates a tunnel with both Bob and Charlie in it, 
        Bob's next hop is always Charlie), we address the issue as Bob doesn't 
        get to substantially sample Alice's peer selection group. We may even 
        want to explicitly allow Bob to participate in Alice's tunnels in only 
        one way - receiving a message from Dave and sending it to Charlie - and 
        if any of those peers are not available to participate in the tunnel (due 
        to overload, network disconnection, etc), avoid asking Bob to participate 
        in any tunnels until they are back online.</p>
      <p>More analysis is necessary for revising the tunnel creation - at the 
        moment, we simply select and order randomly within the peer's top tier 
        of peers (ones with fast + high capacity).</p>
      <p>Adding a strict ordering to peers in a tunnel also improves the anonymity 
        of peers with 0-hop tunnels, as otherwise the fact that a peer's gateway 
        is always the same would be particularly damning. However, peers with 
        0-hop tunnels may want to periodically use a 1-hop tunnel to simulate 
        the failure of a normally reliable gateway peer (so every MTBF*(tunnel 
        duration) minutes, use a 1-hop tunnel).</p>
    </ul>
    <li> 
      <h3 id="tunnelLength">Randomly permuted tunnel lengths</h3>
      <b><i>Addressed in I2P 0.5 as documented <a href="tunnel-alt.html">elsewhere</a></i></b></li>
  </ul>
  <ul class="targetlist">
    <p>Without tunnel length permutation, if someone were to somehow detect that 
      a destination had a particular number of hops, it might be able to use that 
      information to identify the router the destination is located on, per the 
      predecessor attack. For instance, if everyone has 2-hop tunnels, if Bob 
      receives a tunnel message from Charlie and forwards it to Alice, Bob knows 
      Alice is the final router in the tunnel. If Bob were to identify what destination 
      that tunnel served (by means of colluding with the gateway and harvesting 
      the network database for all of the LeaseSets), he would know the router 
      on which that destination is located (and without restricted routes, that 
      would mean what IP address the destination is on).</p>
    <p>It is to counter user behavior that tunnel lengths should be permuted, 
      using algorithms based on the length requested (for example, the 1/MTBF 
      length change for 0-hop tunnels outlined above).</p>
    <li> 
      <h3 id="fullRestrictedRoutes">Full blown n-hop restricted routes with optional 
        trusted links</h3>
      <p>The restricted route functionality described before was simply a functional 
        issue - how to let peers who would not otherwise be able to communicate 
        do so. However, the concept of allowing restricted routes includes additional 
        capabilities. For instance, if a router absolutely cannot risk communicating 
        directly with any untrusted peers, they can set up trusted links through 
        those peers, using them to both send and receive all of its messages. 
        Those hidden peers who want to be completely isolated would also refuse 
        to connect to peers who attempt to get them to (as demonstrated by the 
        garlic routing technique outlined before) - they can simply take the garlic 
        clove that has a request for delivery to a particular peer and tunnel 
        route that message out one of the hidden peer's trusted links with instructions 
        to forward it as requested.</p>
    </li>
    <li> 
      <h3 id="hashcash">Hashcash for routerIdentity, destination, and tunnel request</h3>
      <p>Within the network, we will want some way to deter people from consuming 
        too many resources or from creating so many peers to mount a <a href="http://citeseer.ist.psu.edu/douceur02sybil.html">Sybil</a> 
        attack. Traditional techniques such as having a peer see who is requesting 
        a resource or running a peer aren't appropriate for use within I2P, as 
        doing so would compromise the anonymity of the system. Instead, we want 
        to make certain requests "expensive".</p>
      <p><a href="http://www.hashcash.org/">Hashcash</a> is one technique that 
        we can use to anonymously increase the "cost" of doing certain activities, 
        such as creating a new router identity (done only once on installation), 
        creating a new destination (done only once when creating a service), or 
        requesting that a peer participate in a tunnel (done often, perhaps 2-300 
        times per hour). We don't know the "correct" cost of each type of certificate 
        yet, but with some research and experimentation, we could set a base level 
        that is sufficiently expensive while not an excessive burden for people 
        with few resources.</p>
      <p>There are a few other algorithms that we can explore for making those 
        requests for resources "nonfree", and further research on that front is 
        appropriate.</p>
    </li>
    <li> 
      <h3 id="batching">Advanced tunnel operation (batching/mixing/throttling/padding)</h3>
      <p>To powerful passive external observers as well as large colluding internal 
        observers, standard tunnel routing is vulnerable to traffic analysis attacks 
        - simply watching the size and frequency of messages being passed between 
        routers. To defend against these, we will want to essentially turn some 
        of the tunnels into its own mix cascade - delaying messages received at 
        the gateway and passing them in batches, reordering them as necessary, 
        and injecting dummy messages (indistinguishable from other "real" tunnel 
        messages by peers in the path). There has been a significant amount of 
        <a href="http://freehaven.net/doc/sync-batching/sync-batching.pdf">research</a> 
        on these algorithms that we can lean on prior to implementing the various 
        tunnel mixing strategies.</p>
      <p>In addition to the anonymity aspects of more varied tunnel operation, 
        there is a functional dimension as well. Each peer only has a certain 
        amount of data they can route for the network, and to keep any particular 
        tunnel from consuming an unreasonable portion of that bandwidth, they 
        will want to include some throttles on the tunnel. For instance, a tunnel 
        may be configured to throttle itself after passing 600 messages (1 per 
        second), 2.4MB (4KBps), or exceeding some moving average (8KBps for the 
        last minute). Excess messages may be delayed or summarily dropped. With 
        this sort of throttling, peers can provide ATM-like QoS support for their 
        tunnels, refusing to agree to allocate more bandwidth than the peer has 
        available.</p>
      <p>In addition, we may want to implement code to dynamically reroute tunnels 
        to avoid failed peers or to inject additional hops into the path. This 
        can be done by garlic routing a message to any particular peer in a tunnel 
        with instructions to redefine the next-hop in the tunnel.</p>
    </li>
    <li> 
      <h3 id="stop">Stop &amp; go mix w/ garlics &amp; tunnels</h3>
      <p>Beyond the per-tunnel batching and mixing strategy, there are further 
        capabilities for protecting against powerful attackers, such as allowing 
        each step in a garlic routed path to define a delay or window in which 
        it should be forwarded on. This would enable protections against the long 
        term intersection attack, as a peer could send a message that looks perfectly 
        standard to most peers that pass it along, except at any peers where the 
        clove exposed includes delay instructions.</p>
    </li>
  </ul>
  <h2 id="performance">Performances</h2>
  <p>
  Les am&eacute;liorations de performances sont r&eacute;pertori&eacute;es sur une page d&eacute;di&eacute;e aux
  <a href="performance.html">performances</a>.
  </p>
{% endblock %}
