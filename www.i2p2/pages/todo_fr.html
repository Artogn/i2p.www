{% extends "_layout_fr.html" %}
{% block title %}&Agrave; faire / Sur le feu{% endblock %}
{% block content %} 
  <h1>Cibles du project I2P</h1>
Traduction en cours (25 f&eacute;v 2011)
  <p>Vous trouverez ci-dessous une exposition plus d&eacute;taill&eacute;e (bien que toujours incompl&egrave;te) 
    des principales zones du d&eacute;veloppement du c&oelig;ur du r&eacute;seau I2P, embrassant les
    nouvelles versions &eacute;ventuellement planifi&eacute;es. Ceci n'inclu ni le transport st&eacute;ganographique, 
    ni les outils de s&eacute;curisation de la machine locale et l'adaptation  aux p&eacute;riph&eacute;riques radio (WiFi), pas plus que les applications clientes 
    qui sont tous essentiels pour le succ&egrave;s du r&eacute;seau I2P. Il y a probablement d'autres choses qui 
    viendront, particuli&egrave;rement quand I2P sera mieux test&eacute;, mais il s'agit l&agrave; des principaux 
    "gros morceaux". Voir aussi la <a href="roadmap_fr.html">feuille de route</a>. Vous voulez nous aider? <a href="getinvolved.html">Engagez-vous!</a></p>
  <br />
  <h2>Fonctionalit&eacute;s centrales <font size="-1"><a href="#core">[hop]</a></font></h2>
  <ul class="targetlist">
    <li><a href="#nat">Pontage du Pare-feu/NAT via une route r&eacute;serv&eacute;e &agrave; 1 saut.</a></li>
    <li><a href="#transport">Couche transport de haut-niveau par UDP, NBIO, ou NIO.</a></li>
    <li><a href="#netdb">Base de donn&eacute;e r&eacute;seau, ajustement de profil et strat&eacute;gie d'&eacute;jection pour les grands r&eacute;seaux.</a></li>
  </ul>
  <h2>S&eacute;curit&eacute; / anonymat <font size="-1"><a href="#security">[zyva]</a></font></h2>
  <ul class="targetlist">
    <li><a href="#tunnelId">ID de tunnel "par saut" &amp; nouvelle encryption permut&eacute;e de la structure de v&eacute;rification des tunnels.</a></li>
    <li><a href="#ordering">Position stricte des participants dans les tunnels.</a></li>
    <li><a href="#tunnelLength">Longueur des tunnels al&eacute;atoirement permut&eacute;e.</a></li>
    <li><a href="#fullRestrictedRoutes">Routes r&eacute;serv&eacute;es &agrave; n-sauts finalis&eacute;es avec liens de confiance optionnels.</a></li>
    <li><a href="#hashcash">Hashcash pour routerIdentity, destination, et demande de tunnel.</a></li>
    <li><a href="#batching">Fonctionnement &eacute;tendu des tunnels (batching/mixing/throttling/padding)</a></li>
    <li><a href="#stop">M&eacute;lange de Stop &amp; go pour les <a href="http://www.i2p2.de/how_garlicrouting.html">"garlics"</a> et les tunnels</a></li>
  </ul>
  <h2>Performances <font size="-1"><a href="performance.html">[doigt]</a></font></h2>
  <h2 id="core">Fonctionalit&eacute;s centrales</h2>
  <ul class="targetlist">
    <li> 
      <h3 id="nat">Pontage du Pare-feu/NAT via une route r&eacute;serv&eacute;e &agrave; 1 saut.</h3>
    </li>
    <b><i>Impl&eacute;ment&eacute; dans I2P 0.6.0.6</i></b> 
    <p>La fonctionalit&eacute; permettant aux routeurs de participer pleinement aux r&eacute;seau  
      m&ecirc;me lorsqu'ils se trouvent derri&egrave;re un pare-feu ou un traducteur d'adresses r&eacute;seau (NAT) hors de contr&ocirc;le n&eacute;cessite quelques 
      op&eacute;rations avec une route r&eacute;serv&eacute;e (car ces pairs ne peuvent pas recevoir 
      de connexions entrantes). Pour y parvenir, il y a deux fa&ccedil;ons de consid&eacute;rer les pairs:</p>
  </ul>
  <ul>
    <li><b>Pairs disposant d'interfaces joignables</b> - ils n'ont rien de particulier &agrave; faire.</li>
    <li><b>Pairs ne disposant pas d'interfaces joignables</b> - ces pairs doivent cr&eacute;er 
      un tunnel pointant sur eux dans lequel la passerelle est un des pairs avec lesquels ils ont &eacute;tabli une connexion
      et qui, lui, dispose d'une interface publiquement joignable et a accept&eacute; de jouer le r&ocirc;le "d'entremetteur".</li>
  </ul>
  <ul class="targetlist">
    <p>Pour ce faire, les pairs priv&eacute;s se connectent simplement &agrave; quelques autres, 
      cr&eacute;ent un tunnel &agrave; travers chacun d'eux, et en publient une r&eacute;f&eacute;rence dans leur  
      structure RouterInfo de la base de donn&eacute;e du r&eacute;seau.</p>
    <p>Lorsque quelqu'un souhaite joindre un routeur particulier, il doit d'abord obtenir 
      sa "RouterInfo" &agrave; partir de la base de donn&eacute;e, et il saura s'il peut se connecter  
      directement (cas du pair cible public) ou indirectement. Les connexions directes se passent
      normalement, alors que les indirectes se font via les tunnels publi&eacute;s.</p>
    <p>Quand un routeur veut seulement envoyer un ou deux messages &agrave; un pair cach&eacute;, 
      il peut simplement utiliser le tunnel indirect publi&eacute; pour envoyer les donn&eacute;es utiles. Cependant, 
      si le routeur doit converser souvent avec le pair priv&eacute; (par exemple en tant que participant 
      &agrave; un tunnel), il doit envoyer un message "rout&eacute;-&agrave;-la-garlic" &agrave; travers le tunnel
      indirect au pair cach&eacute;, qui le d&eacute;balle pour y trouver... un message destin&eacute; au routeur originaire.
      Le pair cach&eacute; &eacute;tablit alors une connexion sortante 
      au routeur originaire et &agrave; partir de l&agrave; ces deux  
      routeurs peuvent converser directement sur cette nouvelle connexion.</p>
    <p>Ce sc&eacute;nario ne peut bien s&ucirc;r fonctionner que si le pair originaire peut recevoir des connexions 
      (c'est-&agrave;-dire qu'il ne soit pas lui-m&ecirc;me cach&eacute;). Cependant, s'il est cach&eacute; lui aussi, il peut indiquer dans 
      le message initial de revenir par son propre tunnel d'entr&eacute;e.</p>
    <p>Ceci n'est pas destin&eacute; &agrave; fournir aux pairs un moyen de dissimuler leur adresse IP, 
      mais plut&ocirc;t pour permettre &agrave; ceux op&eacute;rant derri&egrave;re un pare-feu ou un NAT de participer normalement 
      au r&eacute;seau. La dissimulation d'adresse IP demande plus de travail, comme  
      d&eacute;crit <a href="#fullRestrictedRoutes">plus bas</a>.</p>
    <p>Avec cette m&eacute;thode, n'importe quel routeur peut participer &agrave; tout r&ocirc;le dans un tunnel. 
      Dans un but d'efficacit&eacute;, op&eacute;rer en pair cach&eacute; est un mauvais choix pour officier en tant que passerelle d'entr&eacute;e, 
      et dans un tunnel donn&eacute;, deux pairs voisins ne devraient pas &ecirc;tre cach&eacute;s. Mais &ccedil;a n'est pas indispensable.</p>
  </ul>
  <ul class="targetlist">
    <li> 
      <h3 id="transport">Couche transport de haut-niveau par UDP, NBIO, ou NIO.</h3>
      <b><i>UDP et NIO sont impl&eacute;ment&eacute;s dans I2P</i></b> 
      <p>La communication TCP standard dans Java n&eacute;cessite habituellement des appels de socket 
        bloquants, et pour pour emp&ecirc;cher un socket de bloquer le bloquer tout le syst&egrave;me, ces  
        appels sont faits dans leur propres t&acirc;ches. Notre transport TCP actuel
        est impl&eacute;ment&eacute; de fa&ccedil;on na&iuml;ve - pour chaque pair en relation, nous avons 
        une t&acirc;che de lecture et une t&acirc;che d'&eacute;criture. Celle de lecture boucle simplement sur  
        un paquet d'appels read(), construit les messages I2NP et les ajoute &agrave; notre file d'attente 
        interne entrante. Il y a une file d'attente de messages sortants par connexion. La t&acirc;che d'&eacute;criture en extrait les messages 
        et passe les donn&eacute;es &agrave; travers les appels write().</p>
      <p>Nous effectuons ceci assez efficacement d'un point de vue charge UC - &agrave; tout moment, 
        presque toutes ces t&acirc;ches sont au repos, bloqu&eacute;es dans l'attente de grain &agrave; moudre. 
        Cependant, chacune d'entre elles consomme des ressources r&eacute;elles (par exemple sur de tr&egrave;s vieux  
        noyaux Linux, chacune sera souvent mise en &oelig;uvre en tant que processus fork()'ed). 
        &Agrave; mesure de la croissance du r&eacute;seau, le nombre de pairs auxquels chaque routeur voudra s'adresser 
        augmentera (souvenez-vous, I2P est enti&egrave;rement connect&eacute;, c'est-&agrave;-dire que chaque pair doit savoir 
        comment passer des messages &agrave; tous les autres. Le support des routes r&eacute;serv&eacute;es  
        ne r&eacute;duira probablement pas sensiblement le nombre de connexions 
        n&eacute;cessaires). Ce qui veut dire que dans un r&eacute;seau de 100000 routeurs, chaque routeur 
        aura jusqu'&agrave; 199998 t&acirc;ches rien que pour s'occuper des connexions TCP!</p>
      <p>&Eacute;videment, &ccedil;a ne marchera pas. Nous avons besoin d'une couche transport adaptative. 
        Dans Java, nous disposons de deux approches principales:</p>
      <h4>UDP</h4>
      <b><i>Impl&eacute;ment&eacute; dans I2P 0.6 ("SSU") tel que document&eacute; <a href="udp.html">ailleurs</a>.</i></b> 
      <p>L'envoi et la r&eacute;ception de datagrammes UDP sont des op&eacute;rations sans connexion - si 
        on communique avec 100000 pairs, on colle simplement les paquets UDP dans une file 
        d'attente et on fait avec une seule t&acirc;che pour les extraire et les pousser dans le tuyau 
        (et pour recevoir, une seule t&acirc;che en tire les paquets UDP re&ccedil;us et les ajoute dans une file d'entr&eacute;e).</p>
      <p>L'ennui, c'est que l'utilisation de UDP fait perdre les avantages de TCP (r&eacute;ordonnancement, gestion de la congestion, 
        d&eacute;couverte du MTU, etc). Mettre ce code en &oelig;uvre demandera un travail important, 
        mais I2P n'a pas besoin d'&ecirc;tre aussi solide que TCP. Pr&eacute;cis&eacute;ment, 
        lorsque j'ai fait des mesures au simulateur et en r&eacute;el sur Internet,  
        la plupart des messages transf&eacute;r&eacute;s tenaient facilement dans un seul paquet UDP 
        non fragment&eacute;, et les plus gros messages prenaient 20 &agrave; 30 paquets.
        Comme <i>mule</i> le mit en &eacute;vidence, TCP ajoute une surcharge certaine quand il s'agit de g&eacute;rer 
        autant de petits paquets, vu que les ACKs sont du m&ecirc;me ordre de grandeur.
        Avec UDP, nous pouvons optimiser le transport tant pour l'efficacit&eacute; que pour la souplesse
        en prenant en compte les besoins sp&eacute;cifiques d'I2P.</p>
      <p>&Ccedil;a ne va quand-m&ecirc;me pas &ecirc;tre un travail &eacute;norme.</p>
      <h4>NIO or NBIO</h4>
      <b><i>NIO impl&eacute;ment&eacute; dans I2P 0.6.1.22 ("NTCP")</i></b> 
      <p>Java 1.4 propose un jeu de paquetage "New I/O", permettant aux  
        d&eacute;veloppeurs de tirer avantage des possibilit&eacute;s d'E/S non bloquantes du syst&egrave;me d'exploitation 
        - vous pouvez maintenir un grand nombre d'op&eacute;rations d'E/S simultan&eacute;es sans avoir besoin de d&eacute;finir une t&acirc;che 
        d&eacute;di&eacute;e pour chacune. Cette approche est tr&egrave;s prometteuse, car nous pouvons utiliser un grand nombre de connexion 
        simultan&eacute;es et nous n'avons pas besoin d'&eacute;crire une mini-pile TCP pour UDP. Cependant, selon les d&eacute;veloppeurs
        de Freenet les paquetages NIO n'ont pass&eacute; l'&eacute;preuve du feu. De plus, le recours aux NIO impliquerait une 
        incompatibilit&eacute; avec les JVM open-sources telles que <a href="http://www.kaffe.org/">Kaffe</a>, car 
        <a href="http://www.classpath.org/">GNU/Classpath</a> ne les supporte que partiellement. <i>(note: &ccedil;a ne devrait 
        pas durer car il y a eu quelques progr&egrave;s dans les NIO de Classpath, bien qu'en quantit&eacute; inconnue)</i></p>
      <p>Dans la m&ecirc;me veine, il y a l'alternative du paquetage 
        <a href="http://www.eecs.harvard.edu/~mdw/proj/java-nbio/">Non blocking IO</a> - 
        essentiellement une impl&eacute;mentation NIO de salle blanche (&eacute;crite avant la parution des NIO). 
        Il utilise du code natif du SE pour faire les E/S non bloquantes, en pr&eacute;sentant les &eacute;v&egrave;nements via Java. 
        Il semble fonctionner avec Kaffe, mais il a peu d'activit&eacute; de d&eacute;veloppement &agrave; son sujet (probablement 
        &agrave; cause de la parution des NIO de Java 1.4).</p>
    </li>
  </ul>
  <ul class="targetlist">
    <li> 
      <h3 id="netdb">Base de donn&eacute;e r&eacute;seau, ajustement de profil et strat&eacute;gie d'&eacute;jection pour les grands r&eacute;seaux.</h3>
      <p>Dans l'impl&eacute;mentation actuelle de la base de donn&eacute;e r&eacute;seau et de la gestion de profil, 
        on s'est permis quelques raccourcis pratiques. Par exemple, nous n'avons pas de code pour 
        nettoyer les r&eacute;f&eacute;rences aux pairs dans les K-buckets, vu que nous n'avons pas assez de pairs pour avoir ne 
        serait-ce qu'une petite chance d'en remplir une. Alors on garde les pairs dans n'importe quelle liste appropri&eacute;e. 
        Un autre exemple avec les profils de pairs: la quantit&eacute; de m&eacute;moire n&eacute;cessaire pour maintenir chaque profil est suffisamment 
        faible pour que nous puissions garder des milliers de profils bien d&eacute;taill&eacute;s sans aucun probl&egrave;me. 
        Comme nous avons la possibilit&eacute; d'utiliser des profils r&eacute;duits (dont nous pouvons maintenir des centaines de 
        milliers en m&eacute;moire), nous n'avons pas non-plus le code qui ferait la conversion de d&eacute;taill&eacute; en r&eacute;duit et vice-versa,
        ni m&ecirc;me la purge des deux. &Ccedil;a ne serait pertinent d'&eacute;crire ce code maintenant car nous sommes loin d'en avoir besoin 
        avant longtemps.</p>
      <p>Ceci dit, nous devons quand m&ecirc;me garder &ccedil;a en t&ecirc;te car la taille du r&eacute;seau grandit. 
         Il restera du travail, mais on peut le remettre &agrave; plus tard.</p>
    </li>
  </ul>
  <h2 id="security">S&eacute;curit&eacute; / anonymat</h2>
  <ul class="targetlist">
    <li> 
      <h3 id="tunnelId">ID de tunnel "par saut" &amp; nouvelle encryption permut&eacute;e de la structure de v&eacute;rification des tunnels.</h3>
      <b><i>Depuis I2P v0.5 et document&eacute; <a href="tunnel-alt.html">l&agrave;</a>.</i></b> 
      <p>&Agrave l'heure actuelle, quand Alice initie un tunnel entrant &agrave; quatre sauts commen&ccedil;ant par Elvis, 
        puis passant par Dave, puis Charlie,puis Bob, et se terminant chez elle, Alice (A&lt;--B&lt;--C&lt;--D&lt;--E), 
        tous les cinq sont au fait qu'ils participent au tunnel "123", car 
        les messages en font &eacute;tat (TunnelID commun). Nous voulons donner &agrave; chaque saut un 
        identifiant unique de saut de tunnel: Charlie recevra des messages sur le tunnel 234 
        et les transmettra &agrave; Bob par le tunnel 876. Le but est d'emp&ecirc;cher Bob ou 
        Charlie de savoir qu'ils participent au tunnel d'Alice, car quand chaque saut 
        a le m&ecirc;me tunnelID pour un tunnel donn&eacute;, les attaques par coalition sont simples &agrave; mettre en &oelig;uvre. 
      </p> 
      <p>L'ajout d'un TunnelID unique par saut n'est pas difficile, mais c'est insuffisant: 
        Si Dave et Bob sont contr&ocirc;l&eacute;s par le m&ecirc;me attaquant, ils ne pourraient plus identifier un tunnel 
        par leur participation commune via l'information TunnelID, mais seraient quand-m&ecirc;me capable de le  
        faire par simple comparaison des corps de messages et des structures de v&eacute;rification.
        Pour l'emp&ecirc;cher, le tunnel doit appliquer un cryptage &eacute;tag&eacute; tout au long du chemin, 
        &agrave; la fois sur la charge utile et les structures de v&eacute;rification (utilis&eacute;es pour emp&ecirc;cher les attaques 
        par marquages). On a besoin de modifications simples du TunnelMessage, et aussi d'inclure par saut, des cl&eacute;s
        secr&egrave;tes g&eacute;n&eacute;r&eacute;es pendant la cr&eacute;ation du tunnel et pass&eacute;es &agrave; la passerelle du tunnel.
        Nous devons d&eacute;finir une longueur maximale de tunnel (p.e. 16 sauts) 
        et indiquer &agrave; la passerelle de chiffrer le message pour chacune des 16 cl&eacute;s, 
        en ordre inverse, et de crypter la signature du hachage de la charge utile (crypt&eacute;e) &agrave; chaque &eacute;tape. 
        La passerelle envoie alors ce message au premier saut chiffr&eacute; 16 fois, accompagn&eacute; d'un plan 
        &agrave; 16 entr&eacute;e chiffr&eacute; 16 fois. Le premier saut d&eacute;chiffre le plan et la charge utile avec leur clef secr&egrave;te 
        pour chercher dans le plan l'entr&eacute;e associ&eacute;e &agrave; son propre saut (indiqu&eacute;e par le tunnelID unique par saut) 
        et pour v&eacute;rifier la charge utile en la confrontant au hachage sign&eacute; associ&eacute;.
      </p>
      <p>La passerelle dispose encore de plus d'informations que les autre pairs, 
        et sa compromission avec un participant leur permettrait d'identifier leur participation &agrave; un tunnel donn&eacute;.
        De toute fa&ccedil;on, les pairs voisins savent qu'ils participent au m&ecirc;me tunnel, car ils savent &agrave; qui ils 
        envoient un message (et avec les transports IP sans routes r&eacute;serv&eacute;es, ils savent aussi de qui ils re&ccedil;oivent). 
        Malgr&eacute; tout, les deux techniques ci-dessus augmentent tr&egrave;s sensiblement le co&ucirc;t d'obtention d'&eacute;chantillons 
        signifiants dans des tunnels tr&egrave;s longs.</p>
    </li>
    <ul class="targetlist">
      <li> 
        <h3 id="ordering">Position stricte des participants dans les tunnels.</h3>
        <b><i>Implementé dans la v0.6.2</i></b></li>
    </ul>
    <ul class="targetlist">
      <p>Comme Connelly <a href="http://dev.i2p/pipermail/i2p/2004-July/000335.html">a proposé</a> 
        de s'occuper du problème de l'<a href="http://prisms.cs.umass.edu/brian/pubs/wright-tissec.pdf">attaque par 
        predécesseur</a> <a href="http://prisms.cs.umass.edu/brian/pubs/wright.tissec.2008.pdf">(mise à jour 2008)</a>, 
        conserver l'ordre des pairs au sein d'un tunnel (autrement dit,  
        chaque fois qu'Alice crée un tunnel à l'aide de Bob et de Charlie,le saut suivant Bob sera toujours 
        Charlie), nous en sommes protégés car Bob ne peut pas obtenir une connaissance substantielle du 
        groupe de sélection de pairs d'Alice. Nous pourrions même restreindre le mode de participation de Bob à  
        seulement recevoir de Dave et envoyer à Charlie - et l'un d'entre-eux n'est pas disponible 
        (surcharge, déconnexion, etc...), éviter de demander à Bob de participer à un tunnel tant qu'ils ne sont pas  
        de nouveau disponibles.</p>
      <p>Une analyse plus poussée est nécessaire pour repenser la création du tunnel: pour l'instant, 
        nous piochons et ordonnons aléatoirement le premier tiers des pairs (ceux qui ont des capacités élevées et rapides).
      </p>
      <p>L'ajout d'un ordre strict des pairs dans un tunnel améliore aussi l'anonymat des pairs des tunnels à zéro saut, 
        car sinon, le fait que la passerelle d'un pair ait toujours la même passerelle serait rédhibitoire.
        Cependant, les pairs avec un tunnel à zéro saut pourraient de temps en temps utiliser un tunnel à un saut 
        pour simuler la défaillance du pair passerelle habituellement fiable (donc toutes les 
        MTBF*(durée du tunnel)minutes, utiliser un tunnel à un saut).</p>
    </ul>
    <li> 
      <h3 id="tunnelLength">Permutation aléatoire des longueurs de tunnels.</h3>
      <b><i>Prise en compte dans I2P v0.5, lire <a href="tunnel-alt.html">là</a>.</i></b></li>
  </ul>
  <ul class="targetlist">
    <p>Sans la permutation de longueur de tunnel, s'il advenait que quelqu'un puisse de quelque façon 
      détecter qu'une destination se trouve à un certain nombre de sauts, il pourrait mettre à profit  
      cette information pour identifier le routeur se trouvant à cette destination,  
      par l'attaque du prédecesseur. Par exemple, si tout le monde a des tunnels à deux saut, si Bob 
      reçois un message de tunnel de Charlie et le transfère à Alice, Bob déduit qu' 
      Alice est le routeur final du tunnel. Si Bob pouvait identifier la destination à laquelle mène
      ce tunnel (au moyen d'une collusion avec la passerelle et en collectant tous les baux de la base de donnée 
      du réseau), il trouverait le routeur hébergeant la destination (et sans les routes réservées, ça indiquerait 
      l'adresse IP de la destination).</p>
    <p>It is to counter user behavior that tunnel lengths should be permuted, 
      using algorithms based on the length requested (for example, the 1/MTBF 
      length change for 0-hop tunnels outlined above).</p>
 <p> ²&é"'(-è_çà)=</p>
 <p> ¹~#{[|`\^@]}</p>
 <p> ~1234567890°+</p>
 <p> ùµ§</p>
 <p> €ÀÇÉÈœŒâäÂÄêëËÊîïÎÏôÖöÔÜûüÛø</p>
    <li> 
      <h3 id="fullRestrictedRoutes">Full blown n-hop restricted routes with optional 
        trusted links</h3>
      <p>The restricted route functionality described before was simply a functional 
        issue - how to let peers who would not otherwise be able to communicate 
        do so. However, the concept of allowing restricted routes includes additional 
        capabilities. For instance, if a router absolutely cannot risk communicating 
        directly with any untrusted peers, they can set up trusted links through 
        those peers, using them to both send and receive all of its messages. 
        Those hidden peers who want to be completely isolated would also refuse 
        to connect to peers who attempt to get them to (as demonstrated by the 
        garlic routing technique outlined before) - they can simply take the garlic 
        clove that has a request for delivery to a particular peer and tunnel 
        route that message out one of the hidden peer's trusted links with instructions 
        to forward it as requested.</p>
    </li>
    <li> 
      <h3 id="hashcash">Hashcash for routerIdentity, destination, and tunnel request</h3>
      <p>Within the network, we will want some way to deter people from consuming 
        too many resources or from creating so many peers to mount a <a href="http://citeseer.ist.psu.edu/douceur02sybil.html">Sybil</a> 
        attack. Traditional techniques such as having a peer see who is requesting 
        a resource or running a peer aren't appropriate for use within I2P, as 
        doing so would compromise the anonymity of the system. Instead, we want 
        to make certain requests "expensive".</p>
      <p><a href="http://www.hashcash.org/">Hashcash</a> is one technique that 
        we can use to anonymously increase the "cost" of doing certain activities, 
        such as creating a new router identity (done only once on installation), 
        creating a new destination (done only once when creating a service), or 
        requesting that a peer participate in a tunnel (done often, perhaps 2-300 
        times per hour). We don't know the "correct" cost of each type of certificate 
        yet, but with some research and experimentation, we could set a base level 
        that is sufficiently expensive while not an excessive burden for people 
        with few resources.</p>
      <p>There are a few other algorithms that we can explore for making those 
        requests for resources "nonfree", and further research on that front is 
        appropriate.</p>
    </li>
    <li> 
      <h3 id="batching">Advanced tunnel operation (batching/mixing/throttling/padding)</h3>
      <p>To powerful passive external observers as well as large colluding internal 
        observers, standard tunnel routing is vulnerable to traffic analysis attacks 
        - simply watching the size and frequency of messages being passed between 
        routers. To defend against these, we will want to essentially turn some 
        of the tunnels into its own mix cascade - delaying messages received at 
        the gateway and passing them in batches, reordering them as necessary, 
        and injecting dummy messages (indistinguishable from other "real" tunnel 
        messages by peers in the path). There has been a significant amount of 
        <a href="http://freehaven.net/doc/sync-batching/sync-batching.pdf">research</a> 
        on these algorithms that we can lean on prior to implementing the various 
        tunnel mixing strategies.</p>
      <p>In addition to the anonymity aspects of more varied tunnel operation, 
        there is a functional dimension as well. Each peer only has a certain 
        amount of data they can route for the network, and to keep any particular 
        tunnel from consuming an unreasonable portion of that bandwidth, they 
        will want to include some throttles on the tunnel. For instance, a tunnel 
        may be configured to throttle itself after passing 600 messages (1 per 
        second), 2.4MB (4KBps), or exceeding some moving average (8KBps for the 
        last minute). Excess messages may be delayed or summarily dropped. With 
        this sort of throttling, peers can provide ATM-like QoS support for their 
        tunnels, refusing to agree to allocate more bandwidth than the peer has 
        available.</p>
      <p>In addition, we may want to implement code to dynamically reroute tunnels 
        to avoid failed peers or to inject additional hops into the path. This 
        can be done by garlic routing a message to any particular peer in a tunnel 
        with instructions to redefine the next-hop in the tunnel.</p>
    </li>
    <li> 
      <h3 id="stop">Stop &amp; go mix w/ garlics &amp; tunnels</h3>
      <p>Beyond the per-tunnel batching and mixing strategy, there are further 
        capabilities for protecting against powerful attackers, such as allowing 
        each step in a garlic routed path to define a delay or window in which 
        it should be forwarded on. This would enable protections against the long 
        term intersection attack, as a peer could send a message that looks perfectly 
        standard to most peers that pass it along, except at any peers where the 
        clove exposed includes delay instructions.</p>
    </li>
  </ul>
  <h2 id="performance">Performances</h2>
  <p>
  Les am&eacute;liorations de performances sont r&eacute;pertori&eacute;es sur une page d&eacute;di&eacute;e aux
  <a href="performance.html">performances</a>.
  </p>
{% endblock %}
