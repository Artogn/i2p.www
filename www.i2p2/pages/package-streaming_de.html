{% extends "_layout_de.html" %}
{% block title %}Streaming Packet{% endblock %}
{% block content %}
<p>Implementiert einen TCP-&auml;hnliche (zuverl&auml;sslich, authentifiziert,
in Reihenfolge) Satz an Sockets zum Kommunizieren &uuml;ber die IP-&auml;hnlichen
(unzuverl&auml;sslich, unauthentifiziert, unsortiert) I2P Nachrichten.</p>

<p>Falls eine Anwendugn Streams nutzen m&ouml;chte, muss es einen 
{@link net.i2p.client.streaming.I2PSocketManager} von der{@link 
net.i2p.client.streaming.I2PSocketManagerFactory} anfordern, welche
als Antwort intern eine eigene {@link net.i2p.client.I2PSession} aufbaut.
Jede Kommunikation &uuml;ber diese {@link net.i2p.client.I2PSession}
wird vom {@link net.i2p.client.streaming.I2PSocketManager} verwaltet,
da dieser eine eigene Art an Formatierung der gesendeten und empfangenen 
RAW Nachrichten beinhaltet. Falls eine Anwendung Streams von anderen
Klienten aus dem Netzwerk empfangen will, sollte es die blockierenden
{@link net.i2p.client.streaming.I2PServerSocket#accept} Methoden nutzen,
welche einen {@link net.i2p.client.streaming.I2PSocket} zur Verf&uuml;gung
stellen sobald ein neuer Socket verf&uuml;gbar ist. Falls eine Anwendung
einen neuen Stream zu einem Knoten erstellen will, sollte sie dieses mit dem
passendem {@link net.i2p.client.streaming.I2PSocketManager#connect} Aufruf
erledigen.</p>

<p>Es exisitieren auch hier einige einfache Demoanwendungen - {@link
net.i2p.client.streaming.StreamSinkServer} lauscht zu einer Destination
und schreibt die Daten aller Sockets, die es akzeptiert, in individuelle
Dateien, w&auml;hrend {@link net.i2p.client.streaming.StreamSinkClient}
zu einer bestimmten Destination verbindet und eine bestimmte Anzahl an
Zufallsdaten sendet und sich dann disconnected.</p>
{% endblock %}
